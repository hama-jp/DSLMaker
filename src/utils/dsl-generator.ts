import yaml from 'js-yaml'
import { NODE_TYPES } from '@/constants/node-types'
import { DifyDSLFile, DSLGenerateOptions } from '@/types/dify-workflow'

const YAML_OPTIONS: yaml.DumpOptions = {
  indent: 2,
  lineWidth: 120,
  noRefs: true,
  sortKeys: false,
}

const indentBlock = (block: string, depth: number) => {
  const prefix = '  '.repeat(depth)
  return block
    .split('\n')
    .map((line) => (line.length === 0 ? line : `${prefix}${line}`))
    .join('\n')
}

/**
 * Generate YAML DSL content from DifyDSLFile
 */
export function generateDSL(dslFile: DifyDSLFile, options: DSLGenerateOptions = {}): string {
  const { format = 'yaml', includeComments = true } = options

  // Validate DSL before generation if requested
  if (options.validateBeforeGenerate) {
    const validation = validateDSLForGeneration(dslFile)
    if (!validation.isValid) {
      throw new Error(`DSL validation failed: ${validation.errors.join(', ')}`)
    }
  }

  // Clean and prepare the DSL for export
  const cleanedDSL = cleanDSLForExport(dslFile)

  if (format === 'json') {
    return JSON.stringify(cleanedDSL, null, 2)
  }

  // Generate YAML with comments
  let yamlContent = ''

  if (includeComments) {
    yamlContent += generateYAMLWithComments(cleanedDSL)
  } else {
    yamlContent = yaml.dump(cleanedDSL, YAML_OPTIONS)
  }

  return yamlContent
}

/**
 * Generate YAML with helpful comments
 */
function generateYAMLWithComments(dslFile: DifyDSLFile): string {
  const sections: string[] = []

  sections.push('# Dify Workflow DSL File')
  sections.push('# Generated by DSL Maker')
  sections.push('# Format: YAML (.yml)')
  sections.push(`# Version: ${dslFile.version}`)
  sections.push('')

  sections.push('# Application metadata')
  sections.push(yaml.dump({ app: dslFile.app }, YAML_OPTIONS).trimEnd())
  sections.push('')

  sections.push('# DSL format specification')
  sections.push(yaml.dump({ kind: dslFile.kind, version: dslFile.version }, YAML_OPTIONS).trimEnd())
  sections.push('')

  sections.push('# Workflow definition')
  sections.push('workflow:')

  sections.push(indentBlock('# Environment variables for API keys, etc.', 1))
  sections.push(
    indentBlock(
      yaml.dump({ environment_variables: dslFile.workflow.environment_variables ?? [] }, YAML_OPTIONS).trimEnd(),
      1
    )
  )
  sections.push('')

  sections.push(indentBlock('# Application features configuration', 1))
  sections.push(
    indentBlock(
      yaml.dump({ features: dslFile.workflow.features ?? {} }, YAML_OPTIONS).trimEnd() || 'features: {}',
      1
    )
  )
  sections.push('')

  sections.push(indentBlock('# Workflow graph definition', 1))
  sections.push(indentBlock('graph:', 1))

  sections.push(indentBlock('# Node connections', 2))
  sections.push(
    indentBlock(
      yaml.dump({ edges: dslFile.workflow.graph.edges ?? [] }, YAML_OPTIONS).trimEnd(),
      2
    )
  )
  sections.push('')

  sections.push(indentBlock('# Node definitions', 2))
  sections.push(
    indentBlock(
      yaml.dump({ nodes: dslFile.workflow.graph.nodes ?? [] }, YAML_OPTIONS).trimEnd(),
      2
    )
  )

  if (dslFile.workflow.graph.viewport) {
    sections.push('')
    sections.push(indentBlock('# Canvas viewport settings', 2))
    sections.push(
      indentBlock(
        yaml.dump({ viewport: dslFile.workflow.graph.viewport }, YAML_OPTIONS).trimEnd(),
        2
      )
    )
  }

  return `${sections.filter((section, index) => !(section === '' && sections[index - 1] === '')).join('\n')}\n`
}

/**
 * Clean DSL data for export (remove UI-specific fields, etc.)
 */
function cleanDSLForExport(dslFile: DifyDSLFile): DifyDSLFile {
  // Create a deep copy to avoid modifying the original
  const cleaned = JSON.parse(JSON.stringify(dslFile)) as DifyDSLFile

  // Remove any UI-specific or temporary fields
  cleaned.workflow.graph.nodes.forEach(node => {
    // Remove any temporary or UI-specific properties from node data
    if (node.data && typeof node.data === 'object') {
      // Remove properties that shouldn't be in the DSL export
      delete (node.data as any).selected
      delete (node.data as any).dragging
      delete (node.data as any).uiState
    }
  })

  // Ensure required fields have proper defaults
  if (!cleaned.workflow.environment_variables) {
    cleaned.workflow.environment_variables = []
  }

  if (!cleaned.workflow.features) {
    cleaned.workflow.features = {}
  }

  // Sort nodes and edges by creation order (or by ID)
  cleaned.workflow.graph.nodes.sort((a, b) => a.id.localeCompare(b.id))
  cleaned.workflow.graph.edges.sort((a, b) => a.id.localeCompare(b.id))

  return cleaned
}

/**
 * Validate DSL structure before generation
 */
function validateDSLForGeneration(dslFile: DifyDSLFile): { isValid: boolean; errors: string[] } {
  const errors: string[] = []

  // Check required top-level fields
  if (!dslFile.app?.name) {
    errors.push('App name is required')
  }

  if (!dslFile.app?.icon) {
    errors.push('App icon is required')
  }

  if (!dslFile.app?.icon_background) {
    errors.push('App icon background is required')
  }

  if (!dslFile.app?.mode) {
    errors.push('App mode is required')
  }

  if (!dslFile.kind || dslFile.kind !== 'app') {
    errors.push('Kind must be "app"')
  }

  if (!dslFile.version) {
    errors.push('Version is required')
  }

  // Check workflow structure
  if (!dslFile.workflow?.graph) {
    errors.push('Workflow graph is required')
  }

  if (!Array.isArray(dslFile.workflow?.graph?.nodes)) {
    errors.push('Workflow nodes must be an array')
  }

  if (!Array.isArray(dslFile.workflow?.graph?.edges)) {
    errors.push('Workflow edges must be an array')
  }

  // Check for at least one start node
  const startNodes = dslFile.workflow?.graph?.nodes?.filter(node => node.type === NODE_TYPES.START) || []
  if (startNodes.length === 0) {
    errors.push('Workflow must have at least one start node')
  }

  // Validate node structure
  dslFile.workflow?.graph?.nodes?.forEach((node, index) => {
    if (!node.id) {
      errors.push(`Node at index ${index} must have an ID`)
    }

    if (!node.type) {
      errors.push(`Node at index ${index} must have a type`)
    }

    if (!node.position || typeof node.position.x !== 'number' || typeof node.position.y !== 'number') {
      errors.push(`Node at index ${index} must have valid position coordinates`)
    }

    if (!node.data || !node.data.title) {
      errors.push(`Node at index ${index} must have data with a title`)
    }
  })

  // Validate edge structure
  dslFile.workflow?.graph?.edges?.forEach((edge, index) => {
    if (!edge.id) {
      errors.push(`Edge at index ${index} must have an ID`)
    }

    if (!edge.source || !edge.target) {
      errors.push(`Edge at index ${index} must have source and target`)
    }

    // Check if referenced nodes exist
    const nodeIds = new Set(dslFile.workflow.graph.nodes.map(n => n.id))
    if (!nodeIds.has(edge.source)) {
      errors.push(`Edge at index ${index} references non-existent source node: ${edge.source}`)
    }

    if (!nodeIds.has(edge.target)) {
      errors.push(`Edge at index ${index} references non-existent target node: ${edge.target}`)
    }
  })

  return {
    isValid: errors.length === 0,
    errors
  }
}

/**
 * Generate a minimal valid DSL template
 */
export function generateMinimalDSL(name: string = 'New Workflow'): string {
  const template: DifyDSLFile = {
    app: {
      description: '',
      icon: 'ðŸ¤–',
      icon_background: '#EFF1F5',
      mode: 'workflow',
      name
    },
    kind: 'app',
    version: '0.1.5',
    workflow: {
      environment_variables: [],
      features: {},
      graph: {
        edges: [],
        nodes: [
          {
            id: 'start-1',
            type: 'start',
            position: { x: 100, y: 200 },
            data: {
              title: 'Start',
              variables: []
            }
          }
        ],
        viewport: {
          x: 0,
          y: 0,
          zoom: 1
        }
      }
    }
  }

  return generateDSL(template, { includeComments: true })
}

/**
 * Extract workflow summary for display
 */
export function extractWorkflowSummary(dslFile: DifyDSLFile) {
  const nodes = dslFile.workflow.graph.nodes
  const edges = dslFile.workflow.graph.edges

  const nodeTypeCount = nodes.reduce((acc, node) => {
    acc[node.type] = (acc[node.type] || 0) + 1
    return acc
  }, {} as Record<string, number>)

  return {
    name: dslFile.app.name,
    description: dslFile.app.description,
    nodeCount: nodes.length,
    edgeCount: edges.length,
    nodeTypes: nodeTypeCount,
    hasStartNode: nodes.some(n => n.type === NODE_TYPES.START),
    hasEndNode: nodes.some(n => n.type === 'end'),
    version: dslFile.version
  }
}
