# Document Q&A with Memory Pattern
# Knowledge base Q&A with conversation memory

metadata:
  pattern_id: "pattern_doc_qa_mem_001"
  name: "Document Q&A with Memory"
  description: "Conversational document Q&A: Start -> Knowledge Retrieval -> Memory Recall -> LLM with Context -> Memory Update -> End. Maintains conversation history for contextual responses."
  complexity: "complex"
  node_count: 7
  use_cases:
    - "Conversational document search"
    - "Context-aware Q&A systems"
    - "Customer support with history"
    - "Research assistant with memory"
  tags:
    - "knowledge-base"
    - "memory"
    - "conversation"
    - "context-aware"

workflow:
  version: "0.1"
  graph:
    nodes:
      - id: "start_1"
        type: "start"
        data:
          title: "User Question"
          variables:
            - variable: "user_question"
              type: "string"
              label: "User Question"
              required: true
            - variable: "conversation_id"
              type: "string"
              label: "Conversation ID"
              required: false
          desc: "User question with optional conversation ID"
        position:
          x: 100
          y: 200

      - id: "variable_assigner_1"
        type: "variable-assigner"
        data:
          title: "Initialize Memory"
          assignments:
            - variable: "memory_key"
              value: "{{#start.conversation_id#}}"
        position:
          x: 300
          y: 200

      - id: "knowledge_retrieval_1"
        type: "knowledge-retrieval"
        data:
          title: "Search Documents"
          query: "{{#start.user_question#}}"
          dataset_ids: ["main-knowledge-base"]
          retrieval_mode: "multiple"
          multiple_retrieval_config:
            top_k: 3
            score_threshold: 0.6
            reranking_enable: true
        position:
          x: 500
          y: 200

      - id: "code_memory_recall"
        type: "code"
        data:
          title: "Recall Conversation Memory"
          code_language: "python"
          code: |
            # Simple in-memory conversation storage
            conversations = {}

            def main(conversation_id: str, current_question: str) -> dict:
                if not conversation_id:
                    conversation_id = "default"

                # Retrieve conversation history
                history = conversations.get(conversation_id, [])

                # Format history for context
                context = "\n".join([
                    f"Q: {item['question']}\nA: {item['answer']}"
                    for item in history[-3:]  # Last 3 exchanges
                ])

                return {
                    'conversation_history': context,
                    'conversation_id': conversation_id
                }
          variables:
            - variable: "conversation_id"
              value_selector: ["start", "conversation_id"]
            - variable: "current_question"
              value_selector: ["start", "user_question"]
        position:
          x: 500
          y: 100

      - id: "llm_1"
        type: "llm"
        data:
          title: "Answer with Context"
          model:
            provider: "openai"
            name: "gpt-4"
            mode: "chat"
            completion_params:
              temperature: 0.7
          prompt_template:
            - role: "system"
              text: |
                You are a helpful document Q&A assistant.
                Use the provided documents and conversation history to answer questions accurately.
                If the information isn't in the documents, say so.
            - role: "user"
              text: |
                Conversation History:
                {{#code_memory_recall.conversation_history#}}

                Retrieved Documents:
                {{#knowledge_retrieval.result#}}

                Current Question: {{#start.user_question#}}
        position:
          x: 750
          y: 200

      - id: "code_memory_update"
        type: "code"
        data:
          title: "Update Memory"
          code_language: "python"
          code: |
            conversations = {}

            def main(conversation_id: str, question: str, answer: str) -> dict:
                if not conversation_id:
                    conversation_id = "default"

                # Update conversation history
                if conversation_id not in conversations:
                    conversations[conversation_id] = []

                conversations[conversation_id].append({
                    'question': question,
                    'answer': answer
                })

                # Keep only last 10 exchanges
                conversations[conversation_id] = conversations[conversation_id][-10:]

                return {
                    'status': 'memory_updated',
                    'exchanges_stored': len(conversations[conversation_id])
                }
          variables:
            - variable: "conversation_id"
              value_selector: ["code_memory_recall", "conversation_id"]
            - variable: "question"
              value_selector: ["start", "user_question"]
            - variable: "answer"
              value_selector: ["llm", "text"]
        position:
          x: 1000
          y: 200

      - id: "end_1"
        type: "end"
        data:
          title: "Contextual Answer"
          outputs:
            answer: "{{#llm.text#}}"
            conversation_id: "{{#code_memory_recall.conversation_id#}}"
            memory_status: "{{#code_memory_update.status#}}"
        position:
          x: 1250
          y: 200

    edges:
      - id: "start_1-variable_assigner_1"
        source: "start_1"
        target: "variable_assigner_1"
      - id: "variable_assigner_1-knowledge_retrieval_1"
        source: "variable_assigner_1"
        target: "knowledge_retrieval_1"
      - id: "variable_assigner_1-code_memory_recall"
        source: "variable_assigner_1"
        target: "code_memory_recall"
      - id: "knowledge_retrieval_1-llm_1"
        source: "knowledge_retrieval_1"
        target: "llm_1"
      - id: "code_memory_recall-llm_1"
        source: "code_memory_recall"
        target: "llm_1"
      - id: "llm_1-code_memory_update"
        source: "llm_1"
        target: "code_memory_update"
      - id: "code_memory_update-end_1"
        source: "code_memory_update"
        target: "end_1"