import yaml from 'js-yaml'
import { NODE_TYPES } from '@/constants/node-types'
import { DifyDSLFile, DSLGenerateOptions } from '@/types/dify-workflow'

const YAML_OPTIONS: yaml.DumpOptions = {
  indent: 2,
  lineWidth: 120,
  noRefs: true,
  sortKeys: false,
}

const indentBlock = (block: string, depth: number) => {
  const prefix = '  '.repeat(depth)
  return block
    .split('\n')
    .map((line) => (line.length === 0 ? line : `${prefix}${line}`))
    .join('\n')
}

/**
 * Generate YAML DSL content from DifyDSLFile
 */
export function generateDSL(dslFile: DifyDSLFile, options: DSLGenerateOptions = {}): string {
  const { format = 'yaml', includeComments = true } = options

  // Validate DSL before generation if requested
  if (options.validateBeforeGenerate) {
    const validation = validateDSLForGeneration(dslFile)
    if (!validation.isValid) {
      throw new Error(`DSL validation failed: ${validation.errors.join(', ')}`)
    }
  }

  // Clean and prepare the DSL for export
  const cleanedDSL = cleanDSLForExport(dslFile, options)

  if (format === 'json') {
    return JSON.stringify(cleanedDSL, null, 2)
  }

  // Generate YAML with comments
  let yamlContent = ''

  if (includeComments) {
    yamlContent += generateYAMLWithComments(cleanedDSL)
  } else {
    yamlContent = yaml.dump(cleanedDSL, YAML_OPTIONS)
  }

  return yamlContent
}

/**
 * Generate YAML with helpful comments
 */
function generateYAMLWithComments(dslFile: DifyDSLFile): string {
  const sections: string[] = []

  sections.push('# Dify Workflow DSL File')
  sections.push('# Generated by DSL Maker')
  sections.push('# Format: YAML (.yml)')
  sections.push(`# Version: ${dslFile.version}`)
  sections.push('')

  sections.push('# Application metadata')
  sections.push(yaml.dump({ app: dslFile.app }, YAML_OPTIONS).trimEnd())
  sections.push('')

  sections.push('# DSL format specification')
  sections.push(yaml.dump({ kind: dslFile.kind, version: dslFile.version }, YAML_OPTIONS).trimEnd())
  sections.push('')

  sections.push('# Workflow definition')
  sections.push('workflow:')

  sections.push(indentBlock('# Environment variables for API keys, etc.', 1))
  sections.push(
    indentBlock(
      yaml.dump({ environment_variables: dslFile.workflow.environment_variables ?? [] }, YAML_OPTIONS).trimEnd(),
      1
    )
  )
  sections.push('')

  sections.push(indentBlock('# Application features configuration', 1))
  sections.push(
    indentBlock(
      yaml.dump({ features: dslFile.workflow.features ?? {} }, YAML_OPTIONS).trimEnd() || 'features: {}',
      1
    )
  )
  sections.push('')

  sections.push(indentBlock('# Workflow graph definition', 1))
  sections.push(indentBlock('graph:', 1))

  sections.push(indentBlock('# Node connections', 2))
  sections.push(
    indentBlock(
      yaml.dump({ edges: dslFile.workflow.graph.edges ?? [] }, YAML_OPTIONS).trimEnd(),
      2
    )
  )
  sections.push('')

  sections.push(indentBlock('# Node definitions with debug metadata', 2))
  sections.push(indentBlock(generateNodesWithDebugComments(dslFile.workflow.graph.nodes ?? []), 2))

  if (dslFile.workflow.graph.viewport) {
    sections.push('')
    sections.push(indentBlock('# Canvas viewport settings', 2))
    sections.push(
      indentBlock(
        yaml.dump({ viewport: dslFile.workflow.graph.viewport }, YAML_OPTIONS).trimEnd(),
        2
      )
    )
  }

  return `${sections.filter((section, index) => !(section === '' && sections[index - 1] === '')).join('\n')}\n`
}

/**
 * Generate nodes with detailed debug comments for each node
 */
function generateNodesWithDebugComments(nodes: any[]): string {
  if (nodes.length === 0) {
    return 'nodes: []'
  }

  const nodesSections: string[] = []
  nodesSections.push('nodes:')

  nodes.forEach((node, index) => {
    // Add debug comment for this node
    const debugComment = generateNodeDebugComment(node, index)
    nodesSections.push('')
    nodesSections.push(`  # ${debugComment}`)

    // Add variable flow information if available
    const variableInfo = generateVariableFlowComment(node)
    if (variableInfo) {
      nodesSections.push(`  # ${variableInfo}`)
    }

    // Add step run debugging hints
    const stepRunHints = generateStepRunHints(node)
    if (stepRunHints) {
      nodesSections.push(`  # ${stepRunHints}`)
    }

    // Add test input data comment if available
    const testInputComment = generateTestInputComment(node)
    if (testInputComment) {
      nodesSections.push(`  # ${testInputComment}`)
    }

    // Generate the actual node YAML with proper indentation
    const nodeYaml = yaml.dump([node], YAML_OPTIONS)
      .split('\n')
      .map((line, lineIndex) => {
        if (lineIndex === 0 && line.startsWith('- ')) {
          // First line: convert '- ' to '  - '
          return '  ' + line
        } else if (line.length > 0) {
          // Other lines: add 2 spaces for proper indentation
          return '  ' + line
        }
        return line
      })
      .join('\n')
      .trimEnd()

    nodesSections.push(nodeYaml)
  })

  return nodesSections.join('\n')
}

/**
 * Generate debug comment for a specific node
 */
function generateNodeDebugComment(node: any, index: number): string {
  const nodeTitle = node.data?.title || node.type || 'Unknown'
  const nodeIcon = getNodeIcon(node.type)
  return `${nodeIcon} Node ${index + 1}: ${nodeTitle} (${node.type}) [ID: ${node.id}]`
}

/**
 * Generate variable flow comment for debugging
 */
function generateVariableFlowComment(node: any): string | null {
  const inputs = node.data?.inputs || {}
  const outputs = node.data?.outputs || {}
  const variable = node.data?.variable

  const flowInfo: string[] = []

  // Input variables
  const inputKeys = Object.keys(inputs).filter(key => inputs[key] && typeof inputs[key] === 'string')
  if (inputKeys.length > 0) {
    flowInfo.push(`Inputs: ${inputKeys.join(', ')}`)
  }

  // Output variable
  if (variable) {
    flowInfo.push(`Output: ${variable}`)
  } else if (Object.keys(outputs).length > 0) {
    const outputKeys = Object.keys(outputs)
    flowInfo.push(`Outputs: ${outputKeys.join(', ')}`)
  }

  return flowInfo.length > 0 ? `ðŸ”„ Variable Flow - ${flowInfo.join(' | ')}` : null
}

/**
 * Generate Step Run debugging hints
 */
function generateStepRunHints(node: any): string | null {
  const hints = []

  switch (node.type) {
    case NODE_TYPES.START:
      hints.push('Entry point - check input variables and session setup')
      break
    case NODE_TYPES.LLM:
      hints.push('AI processing - verify prompt template and model configuration')
      break
    case NODE_TYPES.CODE:
      hints.push('Code execution - check input data format and error handling')
      break
    case NODE_TYPES.IF_ELSE:
      hints.push('Conditional logic - verify condition evaluation and branch selection')
      break
    case NODE_TYPES.HTTP_REQUEST:
      hints.push('API call - check URL, headers, and response handling')
      break
    case NODE_TYPES.KNOWLEDGE_RETRIEVAL:
      hints.push('RAG retrieval - verify query processing and knowledge base connection')
      break
    case NODE_TYPES.END:
      hints.push('Exit point - verify final outputs and response formatting')
      break
    default:
      if (node.data?.title?.includes('ðŸ”„')) {
        hints.push('Data processing - check input/output variable mapping')
      }
  }

  return hints.length > 0 ? `ðŸ› Step Run Debug - ${hints[0]}` : null
}

/**
 * Generate test input comment from debug metadata
 */
function generateTestInputComment(node: any): string | null {
  const testInputs = node.data?.__debug_test_inputs__
  if (!testInputs) return null

  const inputExample = Object.entries(testInputs)
    .slice(0, 2) // Show max 2 inputs to keep comment concise
    .map(([key, value]) => `${key}: "${value}"`)
    .join(', ')

  return `ðŸ§ª Test Inputs - ${inputExample}${Object.keys(testInputs).length > 2 ? '...' : ''}`
}

/**
 * Get appropriate icon for node type
 */
function getNodeIcon(nodeType: string): string {
  const iconMap: Record<string, string> = {
    [NODE_TYPES.START]: 'ðŸš€',
    [NODE_TYPES.END]: 'ðŸ',
    [NODE_TYPES.LLM]: 'ðŸ¤–',
    [NODE_TYPES.CODE]: 'ðŸ’»',
    [NODE_TYPES.HTTP_REQUEST]: 'ðŸŒ',
    [NODE_TYPES.IF_ELSE]: 'ðŸ”€',
    [NODE_TYPES.KNOWLEDGE_RETRIEVAL]: 'ðŸ“š',
    [NODE_TYPES.TEMPLATE_TRANSFORM]: 'ðŸ”„',
    [NODE_TYPES.VARIABLE_AGGREGATOR]: 'ðŸ“Š',
    [NODE_TYPES.VARIABLE_ASSIGNER]: 'ðŸ“',
    [NODE_TYPES.TOOL]: 'ðŸ”§',
    [NODE_TYPES.ITERATION]: 'ðŸ”',
    [NODE_TYPES.PARAMETER_EXTRACTOR]: 'âš¡',
    [NODE_TYPES.QUESTION_CLASSIFIER]: 'ðŸŽ¯',
    [NODE_TYPES.ANSWER]: 'ðŸ’¬',
    [NODE_TYPES.AGENT]: 'ðŸ‘¤',
  }

  return iconMap[nodeType] || 'âš™ï¸'
}

/**
 * Clean DSL data for export (remove UI-specific fields, etc.)
 */
function cleanDSLForExport(dslFile: DifyDSLFile, options: DSLGenerateOptions = {}): DifyDSLFile {
  // Create a deep copy to avoid modifying the original
  const cleaned = JSON.parse(JSON.stringify(dslFile)) as DifyDSLFile

  // Remove any UI-specific or temporary fields
  cleaned.workflow.graph.nodes.forEach(node => {
    // Remove any temporary or UI-specific properties from node data
    if (node.data && typeof node.data === 'object') {
      // Remove properties that shouldn't be in the DSL export
      delete (node.data as any).selected
      delete (node.data as any).dragging
      delete (node.data as any).uiState

      // Preserve debug metadata if comments are enabled
      if (!options.includeComments) {
        delete (node.data as any).__debug_test_inputs__
      }
    }
  })

  // Ensure required fields have proper defaults
  if (!cleaned.workflow.environment_variables) {
    cleaned.workflow.environment_variables = []
  }

  if (!cleaned.workflow.features) {
    cleaned.workflow.features = {}
  }

  // Sort nodes and edges by creation order (or by ID)
  cleaned.workflow.graph.nodes.sort((a, b) => a.id.localeCompare(b.id))
  cleaned.workflow.graph.edges.sort((a, b) => a.id.localeCompare(b.id))

  return cleaned
}

/**
 * Validate DSL structure before generation
 */
function validateDSLForGeneration(dslFile: DifyDSLFile): { isValid: boolean; errors: string[] } {
  const errors: string[] = []

  // Check required top-level fields
  if (!dslFile.app?.name) {
    errors.push('App name is required')
  }

  if (!dslFile.app?.icon) {
    errors.push('App icon is required')
  }

  if (!dslFile.app?.icon_background) {
    errors.push('App icon background is required')
  }

  if (!dslFile.app?.mode) {
    errors.push('App mode is required')
  }

  if (!dslFile.kind || dslFile.kind !== 'app') {
    errors.push('Kind must be "app"')
  }

  if (!dslFile.version) {
    errors.push('Version is required')
  }

  // Check workflow structure
  if (!dslFile.workflow?.graph) {
    errors.push('Workflow graph is required')
  }

  if (!Array.isArray(dslFile.workflow?.graph?.nodes)) {
    errors.push('Workflow nodes must be an array')
  }

  if (!Array.isArray(dslFile.workflow?.graph?.edges)) {
    errors.push('Workflow edges must be an array')
  }

  // Check for at least one start node
  const startNodes = dslFile.workflow?.graph?.nodes?.filter(node => node.type === NODE_TYPES.START) || []
  if (startNodes.length === 0) {
    errors.push('Workflow must have at least one start node')
  }

  // Validate node structure
  dslFile.workflow?.graph?.nodes?.forEach((node, index) => {
    if (!node.id) {
      errors.push(`Node at index ${index} must have an ID`)
    }

    if (!node.type) {
      errors.push(`Node at index ${index} must have a type`)
    }

    if (!node.position || typeof node.position.x !== 'number' || typeof node.position.y !== 'number') {
      errors.push(`Node at index ${index} must have valid position coordinates`)
    }

    if (!node.data || !node.data.title) {
      errors.push(`Node at index ${index} must have data with a title`)
    }
  })

  // Validate edge structure
  dslFile.workflow?.graph?.edges?.forEach((edge, index) => {
    if (!edge.id) {
      errors.push(`Edge at index ${index} must have an ID`)
    }

    if (!edge.source || !edge.target) {
      errors.push(`Edge at index ${index} must have source and target`)
    }

    // Check if referenced nodes exist
    const nodeIds = new Set(dslFile.workflow.graph.nodes.map(n => n.id))
    if (!nodeIds.has(edge.source)) {
      errors.push(`Edge at index ${index} references non-existent source node: ${edge.source}`)
    }

    if (!nodeIds.has(edge.target)) {
      errors.push(`Edge at index ${index} references non-existent target node: ${edge.target}`)
    }
  })

  return {
    isValid: errors.length === 0,
    errors
  }
}

/**
 * Generate a minimal valid DSL template
 */
export function generateMinimalDSL(name: string = 'New Workflow'): string {
  const template: DifyDSLFile = {
    app: {
      description: '',
      icon: 'ðŸ¤–',
      icon_background: '#EFF1F5',
      mode: 'workflow',
      name
    },
    kind: 'app',
    version: '0.1.5',
    workflow: {
      environment_variables: [],
      features: {},
      graph: {
        edges: [],
        nodes: [
          {
            id: 'start-1',
            type: 'start',
            position: { x: 100, y: 200 },
            data: {
              title: 'Start',
              variables: []
            }
          }
        ],
        viewport: {
          x: 0,
          y: 0,
          zoom: 1
        }
      }
    }
  }

  return generateDSL(template, { includeComments: true })
}

/**
 * Extract workflow summary for display
 */
export function extractWorkflowSummary(dslFile: DifyDSLFile) {
  const nodes = dslFile.workflow.graph.nodes
  const edges = dslFile.workflow.graph.edges

  const nodeTypeCount = nodes.reduce((acc, node) => {
    acc[node.type] = (acc[node.type] || 0) + 1
    return acc
  }, {} as Record<string, number>)

  return {
    name: dslFile.app.name,
    description: dslFile.app.description,
    nodeCount: nodes.length,
    edgeCount: edges.length,
    nodeTypes: nodeTypeCount,
    hasStartNode: nodes.some(n => n.type === NODE_TYPES.START),
    hasEndNode: nodes.some(n => n.type === 'end'),
    version: dslFile.version
  }
}
